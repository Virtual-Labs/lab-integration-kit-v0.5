<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>web-application-security</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-09-15 23:12:23 IST"/>
<meta name="author" content="Ishan Sharma"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">

<h1 class="title">web-application-security</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Handling User Input </a>
<ul>
<li><a href="#sec-1.1">1.1 Varieties of input </a></li>
<li><a href="#sec-1.2">1.2 Approaches to input handling </a>
<ul>
<li><a href="#sec-1.2.1">1.2.1 Reject known bad </a></li>
<li><a href="#sec-1.2.2">1.2.2 Accept known good </a></li>
<li><a href="#sec-1.2.3">1.2.3 Sanitization </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-2">2 Username Harvesting </a>
<ul>
<li><a href="#sec-2.1">2.1 Username harvesting through login error messages </a></li>
<li><a href="#sec-2.2">2.2 Username harvesting through URL-based errors </a></li>
<li><a href="#sec-2.3">2.3 Harvesting Areas </a></li>
</ul>
</li>
<li><a href="#sec-3">3 SQL Injection </a>
<ul>
<li><a href="#sec-3.1">3.1 Injecting into interpreted contexts </a></li>
<li><a href="#sec-3.2">3.2 SQL Injection Payload </a></li>
<li><a href="#sec-3.3">3.3 Causes of SQL Injection </a></li>
<li><a href="#sec-3.4">3.4 Preventing SQL Injection </a></li>
</ul>
</li>
<li><a href="#sec-4">4 Cross-site Scripting (XSS) </a>
<ul>
<li><a href="#sec-4.1">4.1 Parts of an XSS attack </a></li>
<li><a href="#sec-4.2">4.2 XSS Payload </a></li>
<li><a href="#sec-4.3">4.3 Preventing XSS </a>
<ul>
<li><a href="#sec-4.3.1">4.3.1 Input Validation </a></li>
<li><a href="#sec-4.3.2">4.3.2 Output Validation </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-5">5 Cross-site request forgery (XSRF) </a>
<ul>
<li><a href="#sec-5.1">5.1 Preventing XSRF attacks </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Handling User Input </h2>
<div class="outline-text-2" id="text-1">

<p>All user input is untrusted. A huge variety of attacks against web applications involve submitting unexpected input, crafted to cause behavior that was not intended by the
applicatio's designers. Correspondingly, a key requirement for an application's security defenses is that the application must handle user input in a safe manner.
</p>
<p>
Input-based vulnerabilities can arise anywhere within an application's functionality, and in relation to practically every type of technology in common use. <b>Input validation</b> is often cited as the necessary defense against these attacks.
</p>


</div>

<div id="outline-container-1.1" class="outline-3">
<h3 id="sec-1.1"><span class="section-number-3">1.1</span> Varieties of input </h3>
<div class="outline-text-3" id="text-1.1">

<p>A typical web application processes user-supplied data in many different forms. Some kinds of input validation may not be feasible or desirable for all these
forms of input.
The various types of inputs a web application might need to handle are:
</p><ul>
<li>
<b>Form fields</b>: Forms fields can be used to provide various information to the web application like name, address, phone numbers, user-name, password etc. These form fields have to accept variety of scpecial characters.
</li>
<li>
<b>URLs</b>: A web application needs to respond the URLs used to access it. URLs might contain various parameters which could be used to input potentially malicious characters.
</li>
<li>
<b>Cookies</b>: Some websites use cookies to store user and session information. These cookies are transmitted to the web application with every request. 
</li>
<li>
<b>Header</b>: An HTTP header is transmitted to the web application for every request. HTTP header contains various fields which can be easily modified by a malicious client using a web proxy like burpsuite.

</li>
</ul>
</div>

</div>

<div id="outline-container-1.2" class="outline-3">
<h3 id="sec-1.2"><span class="section-number-3">1.2</span> Approaches to input handling </h3>
<div class="outline-text-3" id="text-1.2">

<p>Various broad approaches are commonly taken to the problem of handling user input. Different approaches are often preferable for different situations
and different types of input, and a combination of approaches may sometimes be desirable.
</p>

</div>

<div id="outline-container-1.2.1" class="outline-4">
<h4 id="sec-1.2.1"><span class="section-number-4">1.2.1</span> Reject known bad </h4>
<div class="outline-text-4" id="text-1.2.1">

<p>This approach typically employs a blacklist containing a set of literal strings or patterns that are known to be used in attacks. The validation mechanism blocks
any data that matches the blacklist and allows everything else.
</p>
<p>
In general, this is regarded as the least effective approach to validating user input, for two main reasons:
</p><ul>
<li>
A typical vulnerability in a web application can be exploited using a wide variety of input, which may be encoded or represented in various ways. Except in the simplest of cases, it is likely that a blacklist will omit some patterns of input that can be used to attack the application. Example:
<ul>
<li>
If <b>SELECT</b> is blocked, try <b>SeLeCt</b>
</li>
<li>
If <b>or 1=1&ndash;</b> is blocked, try <b>or 2=2&ndash;</b>
</li>
</ul>
</li>
<li>
Techniques for exploitation are constantly evolving. Novel methods for exploiting existing categories of vulnerabilities are unlikely to be blocked by current blacklists.

</li>
</ul>
</div>

</div>

<div id="outline-container-1.2.2" class="outline-4">
<h4 id="sec-1.2.2"><span class="section-number-4">1.2.2</span> Accept known good </h4>
<div class="outline-text-4" id="text-1.2.2">

<p>This approach employs a whitelist containing a set of literal strings or patterns, or a set of criteria, that is known to match only benign input. The validation
mechanism allows data that matches the whitelist and blocks everything else. Example:
</p>
<p>
In cases where this approach is feasible, it is regarded as the most effective way to handle potentially malicious input. However, there might be cases where a potentially malicious input id accepted.
For example, some people's names contain an apostrophe or hyphen. These can be used in attacks against databases, but it may be a requirement that the application should permit anyone to register
under his or her real name.
</p>
</div>

</div>

<div id="outline-container-1.2.3" class="outline-4">
<h4 id="sec-1.2.3"><span class="section-number-4">1.2.3</span> Sanitization </h4>
<div class="outline-text-4" id="text-1.2.3">

<p>This approach recognizes the need to sometimes accept data that cannot be guaranteed as safe. Instead of rejecting this input, the application sanitizes it in various ways to prevent it from having any adverse effects. 
Potentially malicious characters may be removed from the data, leaving only what is known to be safe, or they may be suitably encoded or escaped before further processing is performed.
For example, the usual defense against cross-site scripting attacks is to HTML-encode dangerous characters before these are embedded into pages of the application.
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Username Harvesting </h2>
<div class="outline-text-2" id="text-2">

<p>Username harvesting allows us to collect valid usernames. By collecting the logins, the user only needs to guess the passwords to gain privileges into the application.
</p>
<p>
Some applications respond differently if a username doesn't exist than if the password is incorrect. They might as well provide a <b>isValidUsername()</b> webservice, as the difference provides us with a binary test for valid usernames.
This test allows us to input a set of possible usernames and automatically determine which ones are valid.
</p>
<p>
The difference is not always apparent. Sometimes it comes in the form of a HTTP redirect and sometimes the resulting URL is different. Most often these two identifiers occur together
</p>

</div>

<div id="outline-container-2.1" class="outline-3">
<h3 id="sec-2.1"><span class="section-number-3">2.1</span> Username harvesting through login error messages </h3>
<div class="outline-text-3" id="text-2.1">

<p>Login error messages are great for the attacker. One of the simpler forms is when the application displays a "<b>Bad username</b>" error if the user does not exist. It then displays an "<b>Incorrect Password</b>" error if the username is correct but the password does not exist.
</p>
</div>

</div>

<div id="outline-container-2.2" class="outline-3">
<h3 id="sec-2.2"><span class="section-number-3">2.2</span> Username harvesting through URL-based errors </h3>
<div class="outline-text-3" id="text-2.2">

<p>Another error which allows an attacker to harvest usernames is to use a parameter in the URL to signify which error condition has happened.
</p><ul>
<li>
User enters a wrong username
<ul>
<li>
<a href="http://website.tld/login.php?error=1">http://website.tld/login.php?error=1</a>
</li>
</ul>
</li>
<li>
User enters a wrong password
<ul>
<li>
<a href="http://website.tld/login.php?error=2">http://website.tld/login.php?error=2</a>

</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2.3" class="outline-3">
<h3 id="sec-2.3"><span class="section-number-3">2.3</span> Harvesting Areas </h3>
<div class="outline-text-3" id="text-2.3">

<p>We can look anywhere where usernames are accepted to find harvesting areas. Typically login fields are checked. But others exist including:
</p><ul>
<li>
Password Reset
</li>
<li>
User Signup
</li>
<li>
Password Recovery
</li>
<li>
Messaging System: Intra-site messaging systems are a great place to verify usernames, once we have an account.

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> SQL Injection </h2>
<div class="outline-text-2" id="text-3">

<p>SQL Injection is when an attacker includes bits of database commands (primarily, SQL) in web forms or parameters which will end up being input to the database. SQL is an interpreted language, and web applications commonly construct SQL statements that incorporate user data
</p>


<pre class="example">SELECT author,title FROM books WHERE publisher ="&lt;user input&gt;";
</pre>



<ul>
<li>
An attacker can insert any input he wants.

</li>
</ul>

</div>

<div id="outline-container-3.1" class="outline-3">
<h3 id="sec-3.1"><span class="section-number-3">3.1</span> Injecting into interpreted contexts </h3>
<div class="outline-text-3" id="text-3.1">

<p>SQL is an interpreted language. Unlike compiled languages in which the complete source code is converted into machine instructions by a compiler at generation time, which are then executed by the processor directly at run time. In interpreted languages, the conversion from source code to machine code is performed statement by statement at run time by an interpreter. Therefore, the code that the interpreter processes is a mix of the instructions written by the programmer and the data supplied by the user. In some situations, an attacker can supply crafted input that breaks out of the data context, usually by supplying some syntax that has a special significance within the grammar of the interpreted language being used. The result is that part of this input gets interpreted as program instructions, which are executed in the same way as if they had been written by the original programmer. 
</p>
<p>
Because of how interpreted languages are executed, a family of vulnerabilities known as code injection arises. If we are injecting SQL statements, then it is called SQL Injection.
</p>
</div>

</div>

<div id="outline-container-3.2" class="outline-3">
<h3 id="sec-3.2"><span class="section-number-3">3.2</span> SQL Injection Payload </h3>
<div class="outline-text-3" id="text-3.2">

<p>These types of flaws allow for data disclosure and other attacks against the application:
</p><ul>
<li>
We could create a user
</li>
<li>
Read the database
</li>
<li>
Modify transactions
</li>
<li>
Change records
</li>
<li>
Scan the internal network

</li>
</ul>

<p>The power of SQL Injection is limited solely by the attacker's understanding of SQL language and creativity.
</p>
</div>

</div>

<div id="outline-container-3.3" class="outline-3">
<h3 id="sec-3.3"><span class="section-number-3">3.3</span> Causes of SQL Injection </h3>
<div class="outline-text-3" id="text-3.3">

<ul>
<li>
The application developer did not perform input validation when they accepted input.
</li>
<li>
The user input is then made part of SQL query.
</li>
<li>
Specially formatted input will cause the SQL database to run attacker’s choice of queries.

</li>
</ul>
</div>

</div>

<div id="outline-container-3.4" class="outline-3">
<h3 id="sec-3.4"><span class="section-number-3">3.4</span> Preventing SQL Injection </h3>
<div class="outline-text-3" id="text-3.4">

<p>Most databases and application development platforms provide APIs for handling untrusted input in a secure way, which prevents SQL injection vulnerabilities 
from arising. In parameterized queries (also known as prepared statements), the construction of a SQL statement containing user input is performed in two steps:
</p><ul>
<li>
The application specifies the query’s structure, leaving placeholders for each item of user input.
</li>
<li>
The application specifies the contents of each placeholder.

</li>
</ul>

<p>Crucially, there is no way in which crafted data that is specified at the second step can interfere with the structure of the query specified in the first step. Because the query structure has already been defined, the relevant API handles any type of placeholder data in a safe manner, so it is always interpreted as data rather than part of the statement’s structure.
</p>
<p>
Example demonstrating parameterized query construction in PHP and MySQL
</p>


<pre class="example">// define the query structure using a question mark as a placeholder for user-supplied input
  String queryText = “SELECT ename,sal FROM EMP WHERE ename = ?”;

// prepare the statement through DB connection “con”
  stmt = con.prepareStatement(queryText);

// add the user input to variable 1 (at the first ? placeholder)
  stmt.setString(1, request.getParameter(“name”));

// execute the query
   rs = stmt.executeQuery();
</pre>




<p>
If parameterized queries are to be an effective solution against SQL injection attacks, you need to keep in mind several important provisos:
</p><ul>
<li>
They should be used for every database queries.
</li>
<li>
Every item of data inserted into the query should be properly parameterized.
</li>
<li>
Parameter placeholders cannot be used for any other parts of the query:
<ul>
<li>
Table and Column names
</li>
<li>
ASC or DESC keywords etc.

</li>
</ul>
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Cross-site Scripting (XSS) </h2>
<div class="outline-text-2" id="text-4">

<p>Cross-Site scripting is an attack in which the aim is to inject HTML or Javascript code in a user's web browser.
</p>


<pre class="example">&lt;?php
$name = $_REQUEST ['name'];
?&gt;
&lt;html&gt;
  &lt;body&gt;
      Hello, &lt;?php echo $name; ?&gt;!
  &lt;/body&gt;
&lt;/html&gt;
</pre>




<p>
The above code prints a welcoming message to the user whose name is retrieved from the <code>$_GET</code> variable.
</p>
<p>
Suppose a user enters the string <b>user1</b> for his name. The following output will be displayed:
<a href="../images/XSS_1.png">file:Normal-Input</a>
</p>
<p>
Suppose a user enters the following javascript code for his name: <b>&lt;script&gt;alert("XSS")&lt;/script&gt;</b> The following output will be displayed.
<a href="../images/XSS_2.png">file:Malicious-Input</a>
</p>
<p>
This happens because the user input is embedded in the webpage and reflected back to the user. The browser can not distinguish the user input from the HTML or Javascript statements. If a web application needs to explicitly tell the browser which part of the webpage is normal HTML or Javascript code and which part is user input.
</p>

</div>

<div id="outline-container-4.1" class="outline-3">
<h3 id="sec-4.1"><span class="section-number-3">4.1</span> Parts of an XSS attack </h3>
<div class="outline-text-3" id="text-4.1">

<ul>
<li>
Server: which is running a vulnerable web application
</li>
<li>
Client Browser: which is tricked into running the code.
</li>
<li>
Attacker: who is hoping to gain by targeting the user.
</li>
<li>
Malicious code: which is sent by the attacker to the user and is executed on the client browser.

</li>
</ul>
</div>

</div>

<div id="outline-container-4.2" class="outline-3">
<h3 id="sec-4.2"><span class="section-number-3">4.2</span> XSS Payload </h3>
<div class="outline-text-3" id="text-4.2">

<ul>
<li>
Virtual Defacement
<ul>
<li>
This attack involves injecting malicious data into a page of a web application to feed misleading information to users of the application.

</li>
</ul>
</li>
<li>
Injecting Trojan Functionality
<ul>
<li>
The intent is to deceive end users into performing some undesirable action, such as entering sensitive data (e.g. authentication details) that is then transmitted to the attacker.

</li>
</ul>
</li>
<li>
Inducing User Actions
<ul>
<li>
If an attacker hijacks a victim's session, he can use the application "as" that user and carry out any action on the user's behalf.

</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-4.3" class="outline-3">
<h3 id="sec-4.3"><span class="section-number-3">4.3</span> Preventing XSS </h3>
<div class="outline-text-3" id="text-4.3">

<p>The root cause of XSS is that user-controllable data is copied into application responses without adequate validation and sanitization. Because the data is being inserted into the raw source code of an HTML page, malicious data can interfere with that page, modifying not only its content but also its structure — breaking out of quoted strings, opening and closing tags, injecting scripts, and so on.
</p>
<p>
To eliminate XSS vulnerabilities, the first step is to identify every instance within the application where user-controllable data is being copied into responses. This includes data that is copied from the immediate request and also any stored data that originated from any user at any prior time, including via out-of-band channels. To ensure that every instance is identified, there is no real substitute for a close review of all application source code.
</p>
<p>
Having identified all the operations that are potentially at risk of XSS and that need to be suitably defended, you should follow a twofold approach to 
prevent any actual vulnerabilities from arising:
</p><ul>
<li>
Input Validation
</li>
<li>
Output Validation

</li>
</ul>

</div>

<div id="outline-container-4.3.1" class="outline-4">
<h4 id="sec-4.3.1"><span class="section-number-4">4.3.1</span> Input Validation </h4>
<div class="outline-text-4" id="text-4.3.1">

<p>There are two ways to validate input: white-listing and black-listing
</p><ul>
<li>
White-listing: The developer specifies what should be allowed in a give field. This should be the recommended approach.
</li>
<li>
Black-listing: The developer identifies known bad characters and the system either filters them out or blocks the request altogether. This type of filtering is very easy to bypass.

</li>
</ul>

<p>Note: Any type of filtering should be performed on the server side only. If filtering is performed at the client side then it can be easily bypassed using a proxy such as burpsuite.
</p>
</div>

</div>

<div id="outline-container-4.3.2" class="outline-4">
<h4 id="sec-4.3.2"><span class="section-number-4">4.3.2</span> Output Validation </h4>
<div class="outline-text-4" id="text-4.3.2">

<p>At the point where the application copies into its responses any item of data that originated from some user or third party, this data should be HTML-encoded to sanitize potentially malicious characters. HTML encoding involves replacing literal characters with their corresponding HTML entities. This ensures that browsers will handle potentially malicious characters in a safe way, treating them as part of the content of the HTML document and not part of its structure. 
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Cross-site request forgery (XSRF) </h2>
<div class="outline-text-2" id="text-5">

<p>Cross-Site Request Forgery (XSRF) is an attack that leverages trust. The trust a website has in the user (or at least the user's browser)
XSRF takes advantage of an active session a browser has with the target website The attack is possible due to predictable perimeters on sensitive transactions.
</p>
<ul>
<li>
Example: A money transfer transaction might have two parameters:- <code>destination_account</code> and an <i>amount</i>.
<ul>
<li>
<code>http://bank.com/transaction?destination_account=&lt;account_number&gt;&amp;amount=&lt;amount&gt;</code>
</li>
</ul>
</li>
</ul>

<p>There's also a session ID, but it is passed automatically from the user's browser to the website. The attacker doesn't need to know about it.
</p>
<p>
The attacker can construct a malicious request by inserting his account number for the <code>destination_account</code> field and a random amount for the <i>amount</i> field. This malicious request can be forwarded to a user who is currently authenticated to <b>bank.com</b> and has a corresponding session cookie set in his browser. When the user clicks the malicious input, his session cookie is forwarded to <b>bank.com</b> which then executes the malicious query.
</p>

</div>

<div id="outline-container-5.1" class="outline-3">
<h3 id="sec-5.1"><span class="section-number-3">5.1</span> Preventing XSRF attacks </h3>
<div class="outline-text-3" id="text-5.1">

<p>XSRF attacks can be prevented by inserting a random token with the query. The token, a nonce, makes part of the request required to perform a given action unpredictable for an attacker
</p><ul>
<li>
Generate a token
</li>
<li>
Include the token as a hidden input to the form
</li>
<li>
Save the token in the session variables












</li>
</ul>
</div>
</div>
</div>
<div id="postamble">
<p class="author"> Author: Ishan Sharma
<a href="mailto:ishan@Ishan-Vaio">&lt;ishan@Ishan-Vaio&gt;</a>
</p>
<p class="date"> Date: 2014-09-15 23:12:23 IST</p>
<p class="creator">HTML generated by org-mode 6.33x in emacs 23</p>
</div>
</div>
</body>
</html>
